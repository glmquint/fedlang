\chapter{Introduction}
Fedlang is a research project of the University of Pisa, which aims to provide a platform for federated learning experiments:
the middleware of Fedlang is written in Erlang and client and server components are written in Python.
The goal of this project is to port the existing client and server components of Fedlang in Golang, particularly focusing on the federated c-means algorithm to prove that the Go language can be used as an alternative to Python for the development of a federated learning platform. 
We also extended the existing framework functionalities to allow for a generic network topology, implementing a ring configuration as an example.

All of the code developed is available over GitHub at the following link: \url{https://github.com/glmquint/fedlang} and it will be referenced throughout this document.

\section{Previous work}
The pre-existing work can be found at the following GitHub repository \url{https://github.com/jlcorcuera/fedlang} and it consists in a study of most of the aspects related to Machine Learning and Deep Learning, oriented in deciding the right enhancements to apply to Fed-Lang, an Erlang and Python-based framework for supporting data scientists in the development of Federated Learning algorithms. The main focus of the project, with respect to other frameworks is the presence of an Erlang middleware for handling the communication aspects, and the possibility to support any kind of Machine Learning and Deep Learning Python framework. There were already some implementations of the federated learning algorithms, namely FedAvg, Federated Fuzzy c-means and Federated TSK-FRBS.

\section{Initial study}
We started the project by studying the existing codebase of Fedlang, to understand the architecture and the functionalities of the system; for this purpose a Docker image was built to reproduce the environment of the system and to avoid any compatibility issues.
We then ran multiple tests to ensure that the system was working correctly and to understand how the middleware interacts with the client and the server. 
We then studied the Go language, to understand how to implement the functionalities of the system in Go, and to understand how to communicate with the Erlang middleware. Before venturing any further, we need to understand why we chose Go as the language for the porting of the system and what are the main differences between Go and Python.

\subsection{Why Go?}
Go is a statically typed, compiled language that is designed to be simple and efficient. It was created by Google in 2007 and it is used in many Google projects, such as Kubernetes, Docker, and others. Go is designed to be simple and efficient, with a focus on performance and scalability. It is a compiled language, which means that it is faster than interpreted languages like Python. Go is also statically typed, which means that it is more reliable and easier to maintain than dynamically typed languages like Python. Go has a garbage collector, which means that it is easier to write memory-safe code in Go than in languages like C or C++. Go has a built-in concurrency model, which makes it easy to write concurrent programs in Go. Go is also designed to be easy to learn and use, with a simple syntax and a small number of keywords.

\section{Development process}
The first main problem was to find a library in Go that could replace PyErlang, which is used in the original system to communicate with the middleware; we found Ergo framework \footnote{\url{https://github.com/ergo-services/ergo}}, which allows us to communicate with an Erlang node using the Erlang distribution protocol.
For this reason, we implemented a simple ping-pong test in order to have a proof of concept of the communication between the Go client and the Erlang middleware, to ensure that we can achieve the same functionalities of the original system. After that, we started to port the server component of Fedlang in Go, also implementing the fedlang\_process class. 

At this point we had an hybrid system, where the server was written in Go and the client in Python (the code can be found as version 0.1\footnote{\url{https://github.com/glmquint/fedlang/releases/tag/v0.1.0}} of the repository cited at the beginning of the document). This proof of concept allowed us to understand the feasibility of the project and to understand the difficulties that we could encounter during the development of the system, but it also allowed us to understand the potential of the Go language in the development of a federated learning platform.

We then completed the porting of the client in Go (v 0.2\footnote{\url{https://github.com/glmquint/fedlang/releases/tag/v0.2.0}}): this allowed us to change the serialization protocol and to finally tweak both client and server with goroutines and go channels. This allowed us to have a fully functional system in Go . One prime example of the benefits of the newer language is the serialization protocol: in the hybrid system, the serialization was done using a library implementing the Pickle protocol\footnote{\url{https://github.com/MacIt/pickle}}, which, although very powerful and flexible, is also slower than the standard Go serialization library. In the full Go version of the system, we used the gob and json libraries for serialization, which are widely used, faster and well suited for the task.

Finally, we tested the system to ensure that the porting was successful and that the system was working correctly, for this scenario we used a docker network and multiple containers for each service to mimic a fully distributed environment. The results of the tests were positive and we were able to demonstrate that the Go language can be used as an alternative to Python for the development of a federated learning platform.

\section{API enrichment}
We added a feature to the system that allows nodes to communicate with each other: this was done with the purpose of leaving to the developer the possibility to use a different topology for the communication between nodes. 
