\chapter{Code organization}
The code we developed is organized as follows:
\begin{itemize}
\item \textbf{FedlangProcess.go} contains core functionalities both for the client and the server. It provides support for all communications 
between nodes and middleware.
\item \textbf{fcmeans\_client.go} contains the client component of Fedlang, which is responsible for executing the steps of the federated learning algoritm.
\item \textbf{fcmeans\_server.go} contains the server component of Fedlang, which is responsible for aggregating the results coming from the clients.
\end{itemize}

\section{FedlangProcess}
A specialization of the \texttt{FedlangProcess} struct must be instantiated using the generic method 
\begin{verbatim}
func StartProcess[T any](
	go_node_id, 
	erl_cookie, 
	erl_client_name, 
	erl_worker_mailbox, 
	experiment_id string)
\end{verbatim}
where:
\begin{itemize}
	\item \texttt{go\_node\_id} is the identifier of the Go node.
	\item \texttt{erl\_cookie} is the Erlang cookie.
	\item \texttt{erl\_client\_name} is the name of the Erlang worker node.
	\item \texttt{erl\_worker\_mailbox} is the name of the Erlang worker mailbox.
	\item \texttt{experiment\_id} is the identifier of the experiment.
	\item \texttt{T} is the type of the struct containing information about the server or the client of the distributed algorithm 
\end{itemize}

Both Client and Server must implement some methods that will be called by the middleware. Those methods should be exported by the package developed by the algorithm programmer (i.e. make them Capitalized). This allows the FedlangProcess to view and call them.

All methods called by the FedlangProcess can have a variading number of parameters and always contain as the last parameter a copy of the FedlangProcess that called them. This is useful if the programmer wants to use some advanced functionality offered by the FedlangProcess, like a peer to peer communication between nodes during the experiment execution.

If a method that is invoked by the FedlangProcess returns an \texttt{etf.Term} object, the FedlangProcess will send it to the Erlang node that called the method. This allows for a more opaque interaction between the distributed algorithm and the middleware, as it doesn't require the developer to know about any communication detail.

\section{Client}
The client must implement the following methods:
\begin{itemize}
	\item \texttt{Init\_client} initializes the client, taking an encoded json string as configuration.
	\item \texttt{Process\_client} executes one step of the federated learning algorithm. Takes as input the experiment id string, the current round number and the encoding of the current centers.
	\item \texttt{Destroy} is called when the experiment is over. It can be used to free resources. Generally kills the computing node.
\end{itemize}

\section{Server}
The server must implement the following methods:
\begin{itemize}
	\item \texttt{Init\_server} initializes the server, taking an encoded json string as configuration.
	\item \texttt{Process\_server} aggregates the results coming from the clients. Takes as input the experiment id string, the current round number and the encoding of the results.
	\item \texttt{Destroy} is called when the experiment is over. It can be used to free resources. Generally kills the computing node.
\end{itemize}

\section{Erlang}
The already existent Erlang code has been modified to allow the use of different programming languages for distributed algorithms development. 
Many hardcoded variables and functions now accept the \texttt{CodeLanguage} atom that is passed as an argument to switch only the relevant piece of code necessary for the different implementations. 
Other than that, the only improvements to the middleware API are the addition of a new message \texttt{fl\_worker\_result\_ack} that can be returned by the worker instead of the classic \texttt{fl\_worker\_result}.
This new message allows the \texttt{StrategyServer} to keep track of the workers that correctly elaborated their result but didn't send them immediately.
This in turns allows the algorithm developer to defer the sending of the results to the server to a later time, for example after the aggregation of all the results in a peer to peer fashion.
